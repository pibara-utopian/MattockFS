Todo for after paper is submitted.
After the paper is submitted, there could be some time left to work on some of the below subjects.

1) Start with non standard archive/mountpoint (2 SP)
   Currently MattockFS starts with a standard mountpoint and archive dd location, if we want to
   make a meshup of multiple servers using MattockFS, we need to allow different mountpoint and 
   archive to be used.
2) Example of API usage with hard-coded (non-framework) mmls module (5 SP)
   Create a simple Python script that implements a non throttling aware mmls module
   to act as simple example for use of the API.
3) Configurable logging facility (5 SP)
   The provenance logging currently goes to a local file. It is likely that we may in the future
   want provenance info to go to the same graph db as module meta data. To allow for something like 
   that, making a configurable loging target is a required step.
4) Build MattockFS deb package for Ubuntu LTS 16.4. (5 SP)
   Currently the installation of MattockFS uses a combination of a python setup script and a bash script
   that is meant to run on Ubuntu and install dependencies. Turning this setup into a regular deb file
   should make installation more standard.
5) API hooks for allowing framework to implicitly set fadvise policy (7 SP)
   If we get an advanced router functionality in a new framework, the ability for the framework to mark
   different fadvise values for processed or generated entities could improve kernel page-cache handling.
6) Create pressentation video for prospect developers (10 SP)
   My dissertation isn't a very direct guideline as how to continue developing a framework on top of MattockFS.
   A pressentation video might be usefull for successive development in order to introduce spin off project members
   to the base working and paradigms used by MattockFS.
7) Improve on job picking performance (10 SP)
   As the evaluation showed, some of the picking policies have rather poor performance. Looking into this issue
   could yield better algoritms and better performance and scalability.
8) Restore state from journal (10 SP)
   If MattockFS is stopped while some AnyCast sets are non empty, these sets are currently lost. We should
   in theory be able to restore the pre-shutdown state from the journal.
9) Secondary opportunistic hashing (15 SP)
   This type of opportunistic hasing is described as an idea in the paper but has not been implemented.
   Implementing this should potentially allow for "incore" driven hashing in the wake of a carving module.
10 Port the base API to C++ (15 SP)
   If we want to implement a C++ version of a module framework, then the Python MattockFS wrapper API around the
   FS-as-API offered by MattockFS, should be ported to C++. 

The above list is ordered by number of story points per item, not by priority.
