\chapter{File-system structure as API}
\section{Base file-system structure} 
\begin{itemize}
  \item \emph{mattockfs.ctl} -> data/<carvpath>.all 
  \item \emph{data/} 
  \begin{itemize}
    \item \emph{<cp-entity>.<ext>} 
    \item \emph{<cp-entity>/} 
    \begin{itemize}
      \item \emph{<cp-entity>.<ext>}
      \item \emph{<cp-entity>} 
    \end{itemize}
  \end{itemize}
  \item \emph{module/}
  \begin{itemize}
    \item \emph{<module-name>.ctl}
  \end{itemize}
  \item \emph{instance}
  \begin{itemize}
    \item \emph{<instance-handle>.ctl}
  \end{itemize}
  \item \emph{job}
  \begin{itemize}
    \item \emph{<job-handle>.ctl}
  \end{itemize}
  \item \emph{newdata}
  \begin{itemize}
    \item \emph{<newdata-handle>.dat}
  \end{itemize} 
\end{itemize}
In this appendix we describe the technical interface to the MattockFS user-space file-system. This interface consists of three main parts. The clasical CarvFS-style interface of the \emph{data} read-only self-flatening carvpath-annotation based data access, the framework geared interface centered around the core concepts of \emph{module}, \emph{instance} and \emph{job}, and the interface for write-once data and meta-data storage. The second and third part aim to be an \emph{API implemented as file-system} interface. To understand the API as file-system interface, we first need to discuss the core concepts of modules,module-instances and jobs, and the concept of sparse capabilities and their use as handle to in-file-system state.
\section{Modules, instances \& jobs}
On a system running MattockFS there can be multiple worker processes running. A worker process handles evidence data or evidence meta-data of a particular type, and the the code for processing such data is called a module. The process running that code is seen as a module instance. There can be multiple instances of the same module running on one machine. This can be particularily usefull for single-threaded modules with a high CPU-load/data-volume ratio on a server with multiple dozens of processing cores. Most modules will need only one instance running on a single MattockFS instance. Most modules will not initiate any work, but wil work with evidence-data or meta-data that is given to its instance as \emph{job}. During the processing of a job, the evidence data is used to either sub-entities (that can be designated by a carvpath annotation), extracted entities that introduce new content to the repository, and evidence meta-data that represents meta information regarding the evidence data. Once a job is done, the module instance needs to submit the evidence-data for further processing by an other module or for chain termination by the data-store-module. Sub-entities , extracted data and meta-data also constitute jobs that must be submitted to other modules. By default the next module will be the data-store-module unless it is changed during job processing by the modulke instance.
\section{Sparse capabilities as handles}
MattockFS aims to provide a least-authority cross-tool labratory variant of a sealed digital evidence bag (S-DEB). To do this, MattockFS runs under a special uid different from that used by any module, and defines all data in the repository as file-system enforced immutable after the initial initialisation. Further, the file-system is made responsable for provenance meta-data regarding the lab tool-chain. The modules provide the normal evidence meta-data as storage entities, but the file-system keeps track of provenance as part as its role as trusted sub-system. In order for the system to truly function as anti-forensics resistant trusted code-base, the running as a different user is not sufficient. The system will need to be hardened to keep module instances from intervering with each others processes and provenance chains, and at the same time, writing modules that can invoke tools that still have access to essential data or sub-functionality is needed to keep the system flexible enough for reactive usage.
In order to facilitate this, we look at the concept of sparse capabilities. Sparse capabilities are authority tokens or handles that are represented as unguessable strings. The same way that in a programming language an object gets passed by reference to an other object, so to can a sparse capability be handed to an other process. An example oth where this technique of using sparse capabilities together with a user-space file-system and hardening setups was shown to be usable is the MinorFS system. We shall be using sparse capabilities for two things in our file-system: For module-instances and for jobs.  
\section{mattockfs.ctl}
This file represents the archive as a whole. It is a symbolic link to a carvpath that represents the current whole repository.
If for example at a given point in time the total repository size is 3298534883328 bytes in size, than \emph{mattockfs.ctl} will be a symbolic link to \emph{data/0+3298534883328.all}. There is no specific meeta-data asociated with this directory entry.
\subsection{mattockfs.ctl::throttle\_info}
This extended attribute is meant as a hint to the framework for throttling purposes. The value is a semicolon seperated list with core file-system figures that may be used to determine if input throttling should be considered.
\begin{itemize}
\item \emph{fadv\_normal\_size} : The total amount of the MattockFS archive currently marked as normal.
\item \emph{fadv\_willneed\_size} : The total amount of the MattockFS archive currently marked as willneed.
\item \emph{fadv\_dontneed\_size} : The total amount of the MattockFS archive currently marked as dontneed.
\item \emph{io\_access\_size} : The total amount of the non-dontneed marked MattockFS archive that has been part of active read or write actions.
\end{itemize}
\section{\emph{data}/}
The data directory is the core of the MattockFS interface. The directory itself has its access mask set to \emph{x} only (0x111). This means that no directory listing is allowed, nor are file or directory creation actions. Files that fall within the size range of the repository don'n need to be created though, they just are, and can be accessed.
\subsection{data/<cp-entity>.<ext>}
Any disignation of a carvpath that is valid within the bounds of the repository can be used to get a read-only pseudo file that can be used by any forensic or non-forensic tool that expect to work on a regular file. These CarvPath files have a set of read only extended attributes to be used either by human operators, the Mattock framework or a possible future user-interface.
The file may be designated with any file extension as to accomodate processing tools. Some tools for processing a specific type of file won't run unless the file name has an expected file extension. For this reason, any file-extension is treated the same.
\subsubsection{data/<cp-entity>.<ext>::path\_state}
In order to minimize the number of OS context switches needed in framework operations, the whole set of file-system level carvpath meta-data, not related to throtling, is made accessable through a single file-system operation as a single read-only extended attribute named '\emph{path\_state}. The value of this extended attribute is a semicolon seperated list of fields with the following info:
\begin{itemize}
\item \emph{state} : The value of this field can be :
\begin{itemize}
\item "non" : This CarvPath is not currently known to the batches sub-system. 
\item "initializing" : This carvpath is currently being initialized by its creator module.
\item "anycast" : This carvpath is currently is an anycast set, waiting for a module to process it.
\item "pending" : This carvpath has been accepted by a module but is not yet finished being processed.
\item "migrating": A migration attempt to an other host is currently taking place.
\end{itemize}
\item \emph{module} : If the state is not \emph{non}, the module that this carvpath is currently bound to.
\item \emph{mime\_type} : If the state is not \emph{non}, the mime-type of the data designated by this carvpath.
\item \emph{prefered\_extension} : If the state is not \emph{non}, the file-extension of the data designated by this carvpath.
\item \emph{hash} : If the state is not \emph{non} and if opportunistic hasing has completed, the BLAKE2 hash of the carvpath entity.
\item \emph{hash\_offset} : If the state is not \emph{non}, and if opportunistic hasing has not yet completed, the offset of the first file-data yet to be included in hash calculation.
\end{itemize}
\subsubsection{data/<cp-entity>.<ext>::throttle\_info}
\subsection{mattockfs.ctl::throttle\_info}
This extended attribute is meant as a hint to the framework for throttling purposes. The value is a semicolon seperated list with core file-system figures that may be used to determine if input throttling should be considered for a specific carvpath. 
\begin{itemize}
\item \emph{fadv\_normal\_size} : The total amount of this carvpath currently marked as normal.
\item \emph{fadv\_willneed\_size} : The total amount of this carvpath currently marked as willneed.
\item \emph{fadv\_dontneed\_size} : The total amount of this carvpath currently marked as dontneed.
\item \emph{io\_access\_size} : The total amount of the non-dontneed marked space belonging to this carvpath that has been part of active read or write actions.
\end{itemize}


\subsection{data/<cp-entity>/}
Without an extension, the CarvPath annotation in the \emph{data} directory refers to a sub directory with special purpose entries. Like the \emph{data} directory, this directory has mode \emph{0x111} and thus can't be listed. The directory provides the possibility to work with nested carvpath entities by means of flatening symbolic links, thus allowing CarvPath aware forensic tools to produce new valid CarvPath entities by designating a relative path and dereferencing the sysmbolic link.
\subsubsection{The cp-entity string}
A cp-entity string has a simple layout that is the same as the string layout used by the original CarvFS implementation. Note though that they are not 100\% compatible dueue to the use of a different hashing algoritm. A carvpath entity string comes in two forms. The full form consists of one or more carvpath-chunk strings separated by underscores. The reduced form consists of a capital character \emph{D} followed by a hexidecimal depiction of the BLAKE2 hash of the full version. This reduced variant is used only when the total size of the full version string would exceed a reasonable treshold. The carvpath-chunk strings also come in two variants. The sparse-chunk string and the fragment-chunk string. A sparse-chunk string consists of a capital \emph{S} character followed by the decimal depiction of the size of the chunk. A fragment chunk consists of the decimal depiction of the fragment offset within its parent entity, followed by a plus (+) character, followed by the decimal depiction of the size of the fragment.
\subsection{data/<cp-entity/<cp-entity> and data/<cp-entity>/<cp-entity>.<ext>}
If an entry itself is a valid CarvPath, with or without an extension, than the entry is represented by a symbolic link back into the \emph{data} directory, carying the exact same extension. The file-system will flatten the carvpath into representing the proper data entity. For example: \emph{data/3145728+786432/ 1048576+65536.gif} will be a symlink to \emph{../4194304+65536.gif}.
\section{module/}
The \emph{module} directory is meant as an entry point to the API into the MatockFS anycast functionality. It allows a module to register as an instance of a given module by means of a simple \emph{chdir} command. Like the \emph{data} directory, the \emph{module} directory has its access mask set to \emph{x} only (0x111). This means that no directory listing is allowed, nor are file or directory creation actions.
\subsection{module/<module-name>.ctl}
If a process wants to register as an instance of a particular module, it should dereference this node as symbolic link. On each readlink invocation a new instance representation is generated within MattockFS. The link should thus only be dereferenced once by every module instance. The link generated refers to a unique per instance controll node where the module instance can start accepting jobs and cooperating with the rest of the Mattock modules.
\subsubsection{module/<module-name>.ctl::weight}
This mutable extended attribute defines the weight that is assigned to the anycast-set of this module for load-balancing purposes. The default value is 100. The weight is meant to represent the CPU/data-volume ratio in such a way that 100 represents the 100\% value of a default module. A very CPU intensive module may have a weight multiple orders of magnitude higher. The idea is that jobs for high weight values are good candidates for migration to other nodes in load-balancing scenarios.
\subsubsection{module/<module-name>.ctl::overflow}
This mutable extended attribute defines the number of entities in the module's anycast-set that should not be considered candidated for migration. The default value is 10. By changing this value, the eagerness of the load-balancing process is tunable. We consider migration to be expensive and premature migration undesireable. It may be desireable to decrease the value of this attribute for high weight modules or to increase it for modules that are low on both IO operations and CPU load, for example modules that only extract limited meta-data from large archives.
\subsubsection{module/<module-name>.ctl::throttle\_info}
Before a module enters extracted entities or sub-entities into the file-system, the module needs to make sure the page-cache does not run the risk of being over-filled. To address this, the file-system provides the throttle\_info meta data attribute. This extended attributes provides information about the anycast-set for designated module. The content of this attribute is a semicolon seperated list with the following meta-data:
\begin{itemize}
\item set\_size : The current number of entities in the anycast set for this module.
\item set\_volume : The current amount of archive data the current anycast set represents.
\end{itemize}
It is up to the envisioned Mattock framework code-base to make sure the information is used for effective throtling, balancing the need for effective system resource and processing power usage with the mittigation of disk-cache-miss leveles.
\subsection{instance/}
Like the \emph{data} and \emph{module} directory, the \emph{instance} directory  has its access mask set to \emph{x} only (0x111). This means that no directory listing is allowed, nor are file or directory creation actions. The directory is meant as holding point for instance handle pseudo directories.
\subsection{instance/<instance-handle>.ctl}
Each module instance has its own instance-handle node for interacting with the MattockFS anycast functionality. The  access mask for this directory is set to \emph{x} only (0x111). Before the node can be used to accept jobs with, it needs to be initiated using a sort pollicy, and in the case of a load-balacer, a select pollicy. After initialisation, if the module anycast-set is non empty, the node is represented by a symbolic link that is dereferenced in order to accept a job from the anycast set.
\subsubsection{instance/<instance-handle>.ctl::sort\_policy}
In our fact-finding study on OCFA timing we discovered that the priority queueing used by OCFA was largely ineffective. In MattockFS we no longer have priority queues, we have sortable sets instead. So rather than asking an Anycast functionality for the next highest priority entity in the queue, we ask for the first entity in the set according to a given sorting pollicy. MattockFS implements a number of choiches to the framework layer in the form of a policy string. The pollicy string consists of a number of consecutive letters that represent set-member properties that can be used for sorting. The next letter from such a string is only used in case of equality according to previous letters. In the end, the entity to be returned will be the one at the start of the resulting sorted set. The sort-policy string can consist of the following letters;
\begin{itemize}
\item \emph{R} : Prefer entities that contain fragment chunks that have the highest currently existing reference-count. The idea would be that processing these entities might have the greatest opportunistic-hashing impact if processing this entity could make the opportunistic hashing of more entities progress.
\item \emph{r} : Prefer entities that contain fragment chunks that have a reference-count of one. The idea would be that processing this entity will allow the refcount=1 chunks to be marked as no longer needed, thus reducing page-cache pressure.
\item \emph{O} : Prefer entities that contain a fragment chunk with the lowest possible fragment offset. The idea would be that opportunistic hashing is sequential and not processing this entity first might intervene with its opportunistic hashing later on.
\item \emph{H} : Prefer entities that contain a fragment chunk with the lowest possible hashing offset parent reference. The idea would be that opportunistic hashing is sequential and not processing this entity first might intervene with its opportunistic hashing later on. The difference with the O lies in the fact that here the data that has already been opportunistically hashed is ignored.
\item \emph{D} : Prefer entities with the lowest density of chunks with the highest currently existing reference-count. The idea is that processing entities containing much highest-refcount fragments are less likely to contribute much to freeing up page-cache in the short run.
\item \emph{d} : Prefer entities with the lowest density of chunks with  a reference-count other than one. The idea would be that processing these first will free up page-cache.
\item \emph{W} : Prefer entities with the lowest weighted average reference count. The idea would be that processing these first would contribute to freeing page-cache in the least amount of steps.
\item \emph{S} : Prefer entities with the lowest total size. The idea is that small entities take up relatively much in-process state for the file-system and can be handled quite quickly.
\item \emph{K} : Ignore the anycast set for the module, create a new kickstarting job instead.
\end{itemize}
Note that different sorting pollicies may be beneficial depending on the current page-cache pressure caused by MattockFS\@.
It might also be different depending on the specific module access patterns and/or system load characteristics. Further research is needed to determine the momt appropriate It is up to the framework, not the file-system to choose the proper sorting pollicy 
\subsubsection{instance/<instance-handle>.ctl::select\_policy}
For normal modules the concept of anycast-set selection is not relevant as those modules only access the set bound to their module name. For the load-balancer however, the next job may come from any module and a set selection pollicy is needed. This policy is partially related to the \emph{weight} and \emph{overflow} extended attributes of \emph{module/<modulename>.register}, settable attributes that plays a part in selecting the set. Like the sort-policy string, the set-selection-policy string consists of a number of ordered characters used in sorting, but now it's the sets themselves that are sorted. Other than for the sort-pollicy string, the sorting will favor the largest value rather than the lowest. It is important to note that the \emph{overflow} extended attribute defines a minimum value of entities in a module's set that is not to result in any migrational activity and thus modules staying below this trehshold will not be part of the sorting and selecting process.
\begin{itemize}
\item \emph{S} : Prefer the set holding the highest number of entities. This pollicy should be prefered for CPU related load-balancing.
\item \emph{V} : Prefer the set with the highest total entity size. This pollicy might be prefered for page-cache over-pressure related load-balancing.
\item \emph{D} : Prever the set with the highest entitycount/volume ratio, what is the same as the lowest average entity size. 
\item \emph{W} : Prefer the the set with the highest weight module (as set with the \emph{weight} extended attribute.
\item \emph{C} : Prefer the set with the highest weight*entitycount/volume number. This should represent small yet CPU intensive jobs that should be very much suitable for migration. 
\end{itemize} 
We suggest that the \emph{C} should be a sane default, and given that this string is ignored for regular modules may be uses for those as well.  

If the module is a kickstart, no job will normally ever be submitted to it. Instead the kickstart can start of a new tool-chain by asking for the creation of a completely new empty job by dereferecing this symbolic link.
\subsubsection{instance/<instance-handle>.ctl::registered}
This attribute will be set to the value \emph{1} untill it ie explicityly set to \emph{0} indicating the de-registration of the module instance.
\section{job/}
This directory is meant to provide the JOB related API functionality for module instances. Like the \emph{data} and \emph{module} directory, the \emph{job} directory has its access mask set to \emph{x} onlu (0x111). So again no directory listing is allowed, nor ar any file or directory creation actions.
\subsection{job/<job-handle>.ctl}
This node is represented as a symbolic link that references the read-only job input-data inside of the main CarvFS style repository \emph{data} directory. It is meanth as main handle for the job processing by a module instance.
\subsubsection{job/<job-handle>.ctl::routing\_info}
By default this extended attribute will be set to to \emph{';'} indicating that the current module is to be the final module in the toolchain for the job data. A module-instance must update this value if the job needs any consecutive routing. The extended attribute is made-up out of two parts separated by a semicolon. The first part is the name of the next module that is to receive this entity as job. The second part is meant to contain a state variable that could be used by a distributed FIVES-OCFA-router style routing facility within the computer-forensic framework. The idea of the FIVES-OCFA-router was that an entity traversed a routing rule-list based on meta-data artifects. When after being processed by an other module the entity returned at the router functionality, the router state string was used to find the location in the rule-list to continue the processing.
A module may update this extended attribute to a valid module name and router state.
\subsubsection{job/<job-handle>.ctl::derive\_child\_entity}
A module instance may create new child entities using a carvpath designation within relative to the parent entity.
This must occure one at a time by first setting this extended attribute to the designated sub-carvpath and than setting the \emph{last\_child\_submit\_info} attribute.
\subsubsection{job/<job-handle>.ctl::create\_mutable\_child\_entity}
If instead of marking an designatable carvpath, a module instance needs new storage to store extracted data or meta-data from the input evidence-data, the module-instance can ask for a new mutable file to store the derived data in. The value of this attribute should be set to the desired data size. After setting this attribute, dereferencing the symbolic link on this node will point to the mutable entity and no longer the input job entity. After the module instance is done writing to the mutable entity, the \emph{last\_child\_submit\_info} attribute should be set apropriately, restoring the symbolic link to its previous target.
\subsubsection{job/<job-handle>.ctl::last\_child\_submit\_info}
If a child job has been marked, the job is new and needs to be submitted as such rather than just having the routing\_info set appropriately.  Submitting a new job requires a small set of MattockFS-level meta-data to be set once, next to the meta-data needed for routing purposes. This extended attribute must be made (by the module instance) to contain the following meta-data:
\begin{itemize}
\item \emph{next-module}
\item \emph{router-state}
\item \emph{mime-type}
\item \emph{file-extention}
\end{itemize}
As with the submit\_info attribute, the values are placed as semicolon separated tokens into a single string.
\subsection{newdata/}
Again a directory with mode 0x111. This directory is meant as holder for fixed-size mutable file entities.
\subsection{newdata/<new-data-handle>.dat}
A file accessable through a new-data-handle is a fixed size mutable data entity that remains valid and mutable within a small time-window determined by the use of job-level attributes. The file may be used for extracted data, for example from a compressed file, or for storage of evidence meta-data. We should look at this time-window as the filling of a digital evidence bag just prior to sealing the bag. All later operations on the data can only take place in a read-only maner, as the data is considered to be sealed after initial initialisation.
